# Authentication System Overview

Based on your codebase, here's a comprehensive explanation of how authentication works:

## Architecture

### 1. **Dual Authentication Methods**

The system supports two authentication approaches:

#### A. **API Key Authentication** (Current/Primary)

- Used for service-to-service or programmatic access
- Bearer token format: `Authorization: Bearer cr_Z2OX-...`
- Keys stored hashed in database (`APIKey` table)

#### B. **OAuth Authentication** (Planned/Future)

- Social login support (Google, GitHub, etc.)
- Configured in `auth/oauth.py`
- Will use OAuth2 authorization code flow

### 2. **Key Components**

#### **Models** (`auth/models.py`)

- **`User`**: Core user entity
  - `id`, `email`, `name`, `role`
  - `created_at`, `updated_at`
  - Relationships to `APIKey` records
  
- **`APIKey`**: API key management
  - `user_id` (foreign key to User)
  - `key_hash` (bcrypt/argon2 hash, never stores plain text)
  - `key_prefix` (e.g., "cr_Z2OX" for identification)
  - `name`, `description` (for key management)
  - `is_active`, `expires_at`, `last_used_at`

- **`UserRole`**: Enum defining access levels
  - `ADMIN`, `CONTRIBUTOR`, `VIEWER` (likely)

#### **Service Layer** (`auth/service.py`)

Handles authentication logic:

- `generate_api_key()`: Creates secure keys with hash
- `verify_api_key()`: Validates incoming keys
- `get_user_by_api_key()`: Retrieves user from valid key
- Key rotation and expiration management

#### **Dependencies** (`auth/dependencies.py`)

FastAPI dependency injection for route protection:

```python
async def get_current_user(api_key: str = Depends(oauth2_scheme)):
    # Validates API key from Authorization header
    # Returns User object or raises 401
    
async def require_admin(user: User = Depends(get_current_user)):
    # Checks if user has admin role
    # Raises 403 if insufficient permissions
```

#### **Router** (`auth/router.py`)

API endpoints for authentication:

- `POST /auth/login` - OAuth login redirect
- `GET /auth/callback` - OAuth callback handler
- `POST /auth/keys` - Generate new API key (admin only)
- `GET /auth/keys` - List user's API keys
- `DELETE /auth/keys/{key_id}` - Revoke API key
- `GET /auth/me` - Get current user info

#### **Schemas** (`auth/schemas.py`)

Pydantic models for request/response validation:

- `UserResponse`, `APIKeyResponse`
- `CreateAPIKeyRequest`, `APIKeyListResponse`

### 3. **Request Flow**

```text
1. Client Request
   ↓
   Authorization: Bearer cr_Z2OX-sk3t7M1b5VKGs1l4ZzLUHIdKCIx
   ↓
2. FastAPI Middleware/Dependency
   ↓
   oauth2_scheme extracts token → get_current_user()
   ↓
3. auth_service.verify_api_key()
   ↓
   - Hash incoming key
   - Query APIKey table for matching hash
   - Check if active and not expired
   - Update last_used_at timestamp
   ↓
4. Load User from database
   ↓
   - Join User table via user_id
   - Check role permissions
   ↓
5. Inject User into route handler
   ↓
   - Route receives authenticated User object
   - Can access user.id, user.role, etc.
```

### 4. **Database Schema** (from migrations)

#### `002_auth_tables.py` migration creates

**users table:**

```sql
- id (UUID, primary key)
- email (unique, indexed)
- name
- role (enum: admin/contributor/viewer)
- created_at, updated_at
```

**api_keys table:**

```sql
- id (UUID, primary key)
- user_id (foreign key → users.id)
- key_hash (bcrypt hash)
- key_prefix (first 8 chars for display)
- name, description
- is_active (boolean)
- expires_at (nullable timestamp)
- last_used_at (nullable timestamp)
- created_at
```

### 5. **Security Features**

- **Password hashing**: Keys stored as bcrypt/argon2 hashes
- **Key prefixes**: Allow identification without exposing full key
- **Expiration**: Keys can have time limits
- **Revocation**: Keys can be deactivated
- **Last used tracking**: Audit trail for key usage
- **Role-based access**: Permissions tied to user roles

### 6. **Current Setup** (from .env)

```bash
ADMIN_API_KEY=cr_Z2OX-sk3t7M1b5VKGs1l4ZzLUHIdKCIx
```

This key was generated by `seed_admin.py` for user `SVR-Hub-Dev@outlook.com` with admin role.

### 7. **Usage in Routes**

```python
# Public endpoint (no auth)
@router.get("/public/data")
async def get_public_data():
    return {"data": "public"}

# Authenticated endpoint
@router.get("/protected/data")
async def get_protected_data(user: User = Depends(get_current_user)):
    return {"data": "protected", "user_id": user.id}

# Admin-only endpoint
@router.post("/admin/action")
async def admin_action(user: User = Depends(require_admin)):
    return {"action": "performed", "by": user.email}
```

### 8. **Future OAuth Integration**

When OAuth is implemented (`auth/oauth.py`):

- Users can log in via Google/GitHub
- OAuth tokens exchanged for session tokens
- API keys remain for programmatic access
- Same `User` model supports both auth methods

This is a **hybrid authentication system** designed for both human users (OAuth) and services (API keys).

User:
an you explain why you said this: ""?

GitHub Copilot: I said **"The comment mentions 'before OAuth is configured'"** because of this line in the `seed_admin.py` script's docstring:

```python
"""
Seed an admin user and generate an API key for initial access.

...

This script creates an admin user (if not exists) and generates an API key
that can be used for initial API access before OAuth is configured.
"""
```

The phrase **"before OAuth is configured"** in the script's documentation suggests that:

1. **Current state**: The app uses API key authentication as the primary/only auth method
2. **Future plan**: OAuth (social login) will be added later as an additional authentication option
3. **Purpose of seed script**: Provides a way to bootstrap the system and get initial admin access without needing OAuth set up first

This is confirmed by:

- The presence of `auth/oauth.py` in your codebase (OAuth infrastructure exists but may not be fully implemented)
- The .env file only containing `ADMIN_API_KEY` (no OAuth client IDs/secrets configured)
- The README doesn't mention OAuth login, only API endpoints

So the seed script creates a temporary/initial way to authenticate while OAuth integration is still being developed or configured.
