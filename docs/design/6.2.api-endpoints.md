# FastAPI endpoints

Everything below is designed to plug into our MVP architecture:  
**Postgres ‚Üí SQLAlchemy ‚Üí FastAPI ‚Üí SvelteKit UI ‚Üí LLM reasoning pipeline.**

---

## üß© FastAPI Endpoint Sketches  

These cover the core flows:

1. **Ingest community knowledge**  
2. **Query (retrieve + reason)**  
3. **List knowledge entries**  
4. **Log feedback**  
5. **Optional: ingest events & assets**

---

## üêç `app.py` (FastAPI skeleton)

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional
from db import SessionLocal
from models import CommunityKnowledge, CommunityEvent, CommunityAsset, ModelFeedbackLog
from services.embeddings import embed_text
from services.retrieval import retrieve_relevant_entries
from services.reasoning import run_reasoning_model

app = FastAPI()
```

---

## 1Ô∏è‚É£ **Ingest Community Knowledge**

### **POST /ingest**

```python
class KnowledgeIn(BaseModel):
    title: str
    description: str
    tags: Optional[List[str]] = None
    location: Optional[str] = None
    hazard_type: Optional[str] = None
    source: Optional[str] = None

@app.post("/ingest")
def ingest_knowledge(item: KnowledgeIn):
    db = SessionLocal()
    embedding = embed_text(item.description)

    entry = CommunityKnowledge(
        title=item.title,
        description=item.description,
        tags=item.tags,
        location=item.location,
        hazard_type=item.hazard_type,
        source=item.source,
        embedding=embedding
    )

    db.add(entry)
    db.commit()
    db.refresh(entry)
    return {"status": "ok", "id": entry.id}
```

---

## 2Ô∏è‚É£ **Query (Retrieve + Reason)**  

This is the heart of our MVP.

### **POST /query**

```python
class QueryIn(BaseModel):
    text: str

@app.post("/query")
def query_reasoning(payload: QueryIn):
    db = SessionLocal()

    # 1. Embed the user input
    query_embedding = embed_text(payload.text)

    # 2. Retrieve relevant knowledge + assets
    knowledge = retrieve_relevant_entries(db, query_embedding)

    # 3. Run reasoning model
    model_output = run_reasoning_model(
        user_input=payload.text,
        context_entries=knowledge
    )

    # 4. Log the interaction
    log = ModelFeedbackLog(
        user_input=payload.text,
        retrieved_knowledge_ids=[k.id for k in knowledge],
        model_output=model_output
    )
    db.add(log)
    db.commit()

    return {
        "summary": model_output["summary"],
        "actions": model_output["actions"],
        "rationale": model_output["rationale"],
        "retrieved": [k.id for k in knowledge]
    }
```

---

## 3Ô∏è‚É£ **List Knowledge Entries**

### **GET /knowledge**

```python
@app.get("/knowledge")
def list_knowledge():
    db = SessionLocal()
    entries = db.query(CommunityKnowledge).all()
    return [
        {
            "id": e.id,
            "title": e.title,
            "tags": e.tags,
            "location": e.location,
            "hazard_type": e.hazard_type
        }
        for e in entries
    ]
```

---

## 4Ô∏è‚É£ **Submit Feedback**

### **POST /feedback**

```python
class FeedbackIn(BaseModel):
    log_id: int
    rating: int
    comments: Optional[str] = None

@app.post("/feedback")
def submit_feedback(payload: FeedbackIn):
    db = SessionLocal()
    log = db.query(ModelFeedbackLog).filter_by(id=payload.log_id).first()

    if not log:
        return {"error": "log not found"}

    log.rating = payload.rating
    log.comments = payload.comments
    db.commit()

    return {"status": "feedback recorded"}
```

---

## 5Ô∏è‚É£ **Optional: Ingest Events & Assets**

### **POST /events**

```python
class EventIn(BaseModel):
    event_type: str
    description: str
    location: Optional[str] = None
    severity: Optional[int] = None
    reported_by: Optional[str] = None

@app.post("/events")
def ingest_event(event: EventIn):
    db = SessionLocal()
    embedding = embed_text(event.description)

    entry = CommunityEvent(
        event_type=event.event_type,
        description=event.description,
        location=event.location,
        severity=event.severity,
        reported_by=event.reported_by,
        embedding=embedding
    )

    db.add(entry)
    db.commit()
    return {"status": "ok", "id": entry.id}
```

---

### **POST /assets**

```python
class AssetIn(BaseModel):
    name: str
    asset_type: str
    description: Optional[str] = None
    location: Optional[str] = None
    capacity: Optional[int] = None
    status: Optional[str] = None
    tags: Optional[List[str]] = None

@app.post("/assets")
def ingest_asset(asset: AssetIn):
    db = SessionLocal()
    embedding = embed_text(asset.description or "")

    entry = CommunityAsset(
        name=asset.name,
        asset_type=asset.asset_type,
        description=asset.description,
        location=asset.location,
        capacity=asset.capacity,
        status=asset.status,
        tags=asset.tags,
        embedding=embedding
    )

    db.add(entry)
    db.commit()
    return {"status": "ok", "id": entry.id}
```

---

## üß† What We Now Have

You‚Äôve got a complete FastAPI backend that supports:

- **Knowledge ingestion**  
- **Vector retrieval**  
- **LLM reasoning**  
- **Feedback logging**  
- **Event & asset ingestion**  
- **Frontend‚Äëfriendly JSON responses**
